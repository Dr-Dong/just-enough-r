[
["r-basics.html", "1 Working with R", " 1 Working with R There are many ways of working with R. This guide focusses on a fairly specific setup and workflow, and assumes you will use the RStudio editor, use R markdown documents to document and share your analyses, and install a number of recent packages, including the ‘tidyverse’, which give working with R a shallower learning curve, and let you get powerful things done quickly. "],
["installation-intro.html", "Installation", " Installation Installing on your own machine. Download RStudio 1.01 or later Use whatever version is most recent and expect to upgrade every 6 months or so, as new versions become available. Install the packages listed below Optionally, if you want to ‘knit’ your work into a pdf format, you should also install LaTeX. For most people this isn’t necessary, and is something you can skip for the moment, but it can be helpful when sharing finished analyses with colleagues. On windows use this installer. Make sure to do a ‘full install’, not just a basic install. On a Mac install homebrew and type brew cask install mactex. Package dependencies If you are just gettign started on a windows machine, these instructions for students at Plymouth University make it easy to install R and most of the packages necessary to complete the examples in this book. Further details of a recommended installation are given here. These scripts will install all needed packages on a recent Linux or Mac system. For some of the sections on Bayesian estimation you will also need to install rstan and rstanarm. Details are also here, but this can wait till later. "],
["start-here.html", "Workflow", " Workflow One big adjustment to make when moving away tools like SPSS is to find a ‘way of working’ that suits you. We have often developed ways of working, saving, and communicating our work, and become comfortable with them. In part, these habits and routines may be attempts to work around limitations of these tools. But nevertheless, habits are easier to replace than break, so here’s an alternative model to adopt: Work in RStudio, and use RMarkdown documents (see next sections). Save your raw data in .csv format. Never edit data by hand unless absolutely necessary. Use R to process your data and RMarkdown to document the process. RMarkdown Conventional statistics software like SPSS lacks a simple way to document and share your analyses, and make repeating or editing your work later very hard. RMarkdown is a format for documenting and sharing statistical analyses. This it might seem an odd place to start: we haven’t got anything to share yet! But using RMarkdown in RStudio provides a really nice way to work with data interactively and share our results, so we start as we mean to go on. You are currently reading the output of an ‘RMarkdown’ document. An RMarkdown document mixes R code with Markdown: R is a computer language designed for working with data. Markdown is a simple text-based format which can include prose, hypertext links, images, and code (see http://commonmark.org/help/). Like computer code, RMarkdown can be ‘run’ or ‘executed’. But in the language of RStudio, you ‘knit’ your RMarkdown to produce a finished document. This combines analyses, graphs, and explanatory text in a single pdf, html, or Word document which can be shared. RStudio RStudio is a special text editor that has been customised to make working with R easy. It can be installed on your own computer, or you can login to a shared RStudio server (for example, one run by your university) from a web browser. Either way the interface is largely the same and contains 4 main panels: The figure above shows the main RStudio interface, comprising: The main R-script or RMarkdown editor window. This is where you write commands, which can then be executed (to run the current line type ctrl-Enter or cmd-Enter on a Mac). The R console, into which you can type R commands directly, and see the output of commands run in the script editor. The ‘environment’ panel, which lists all the variables you have defined and currently available to use. The files and help panel. Within this panel the ‘files’ tab enables you to open files stored on the server, in the current project, or elsewhere on your hard drive. You can see a short video demonstrating the RStudio interface here: The video: Shows you how to type commands into the Console and view the results. Run a plotting function, and see the result. Create RMarkdown file, and ‘Knit’ it to produce a document containing the results of your code and explanatory text. Once you have watched the video: Try creating a new RMarkdown document in RStudio. Edit some of the text, and press the Knit button to see the results. If you feel brave, edit one of the R blocks and see what happens! Writing and ‘knitting’ RMarkdown To include R code within RMarkdown we write 3 backticks (```), followed by {r}. We the include our R code, and close the block with 3 more backticks (how to find the backtick on your keyboard). A code chunk in the RMarkdown editor When a document including this chunk is run or ‘knitted’, the final result will include the the line 2+2 followed by the number 4 on the next line. We can use RMarkdown to ‘show our workings’: our analysis can be interleaved with narrative text to explain or interpret the calculations. More about RMarkdown A more detailed guide to using RMarkdown, which covers many of the ‘chunk options’ available to customise output, is available here If you’d like to use RMarkdown to include manage your citations, see this guide "],
["first-commands.html", "First commands", " First commands You can type R commands directly into the console and see the result there, but you should make a habit of working in an RMarkdown file. This keeps a record of everything you try, and makes it easy to edit/amend commands which don’t work as you expect. Now would be a good time to open an RMarkdown document to see how it works. A good place to start would be to open the source to this document. The best way to do this is to download the source code for the ‘Just Enough R’ project, and then open the file start_here.Rmd. The source for this RMarkdown file is available here: https://raw.githubusercontent.com/benwhalley/just-enough-r/master/start_here.Rmd. Or you can download the whole project here: https://github.com/benwhalley/just-enough-r/archive/master.zip. This link downloads a ‘zip’ file, which is a compressed folder containing all the files in the project. To ‘unzip’ it on Mac or Windows just double-click the file in the Finder or Windows Explorer. To run code in the RStudio interface put your cursor on a line within an R Block (or select the code you want to run), and press Ctrl-Enter. The result will appear below the code block. The command in the R block below prints (shows on screen) the first few rows of the build-in mtcars example dataset. Place your cursor somewhere in the line the command is on and run it by typing Ctrl-Enter, shown in this brief video: Create an R block in RMarkdown, then run some simple commands. head(mtcars) mpg cyl disp hp drat wt qsec vs am gear carb Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 If you are reading this from within RStudio, running head(mtcars) will have included an interactive table in the document, which you can use this to view the mtcars dataset. If you are still reading the compiled html or pdf document you will see a table containing the same data, included within the body of the document. Hopefully at this point it’s obvious that RStudio and RMarkdown give you: A nice place to work with R and explore your data A nice format to share your workings (e.g. with other researchers or your tutor) A mechanism to save reports of your analysis, to share with other people who don’t use RStudio "],
["variables.html", "Naming things", " Naming things We can assign labels to the results of calculations and other parts of our analyses to keep track of them. To assign labels we use the &lt;- symbol. The &lt;- symbol points from the value we want to store, to the name we want to use. For example: the_magic_number &lt;- 3 This assigns the value 3 to the variable the_magic_number. This block wouldn’t display anything because assigning a variable doesn’t create any output. To both assign a variable and display it we would type: the_magic_number &lt;- 3 the_magic_number [1] 3 Or we can use a shortcut: if we wrap the line in parentheses this both makes the assignment and prints the result to the console: (i_am_a_new_variable &lt;- 22) [1] 22 Helpfully, we can do calculations as we assign variables: one_score &lt;- 20 (four_score_years_and_ten &lt;- one_score * 4 + 10) [1] 90 We can give anything a label by assigning it to a variable. It doesn’t have to be a number: we can also assign words, graphics and plots, the results of a statistical model, or lists of any of these things. "],
["vectors-and-lists.html", "Vectors and lists", " Vectors and lists When working with data, we often have lists or sequences of ‘things’. For example: a list of measurements we have made. When all the things are of the same type, R calls this a vector1. When there is a mix of different things R calls this a list. Vectors We can create a vector of numbers and display it like this: # this creates a vector of heights, in cm heights &lt;- c(203, 148, 156, 158, 167, 162, 172, 164, 172, 187, 134, 182, 175) The c() command is shorthand for combine, so the example above combines the individual elements (numbers) into a new vector. We can create a vector of alphanumeric names just as easily: names &lt;- c(&quot;Ben&quot;, &quot;Joe&quot;, &quot;Sue&quot;, &quot;Rosa&quot;) And we can check the values stored in these variables by printing them. You can either type print(heights), or just write the name of the variable alone, which will print it by default. E.g.: heights [1] 203 148 156 158 167 162 172 164 172 187 134 182 175 Try creating your own vector of numbers in a new code block below2 using the c(...) command. Then change the name of the variable you assign it to. Accessing elements Once we have created a vector, we often want to access the individual elements again. We do this based on their position. Let’s say we have created a vector: my.vector &lt;- c(10, 20, 30, 40) We can display the whole vector by just typing its name, as we saw above. But if we want to show only the first element of this vector, we type: my.vector[1] [1] 10 Here, the square brackets specify a subset of the vector we want - in this case, just the first element. Selecting more than one element A neat feature of subsetting is that we can grab more than one element at a time. To do this, we need to tell R the positions of the elements we want, and so we provide a vector of the positions of the elements we want. It might seem obvious, but the first element has position 1, the second has position 2, and so on. So, if we wanted to extract the 4th and 5th elements from the vector of heights we saw above we would type: elements.to.grab &lt;- c(4, 5) heights[elements.to.grab] [1] 158 167 We can also make a subset of the original vector and assign it to a new variable: first.two.elements &lt;- heights[c(1, 2)] first.two.elements [1] 203 148 Making and slicing with sequences One common task in R is to create sequences of numbers, letters or dates. The simplest way of doing this is to define a range, with the colon: onetoten &lt;- 1:10 onetoten [1] 1 2 3 4 5 6 7 8 9 10 This creates a vector which can be sliced like any other: onetoten[8] [1] 8 One common use of sequences is to slice other vectors: onetoten[1:3] [1] 1 2 3 Or the first 10 values in the heights vector we defined above: heights[1:10] [1] 203 148 156 158 167 162 172 164 172 187 This works backwards, and with negative numbers too: 5:-5 [1] 5 4 3 2 1 0 -1 -2 -3 -4 -5 When your sequence doesn’t contain only whole numbers, or non-consecutive numbers, you can use the seq function: seq(1,10,by=2) [1] 1 3 5 7 9 seq(0, 1, by=.2) [1] 0.0 0.2 0.4 0.6 0.8 1.0 Conditional slicing One neat feature of R is that you can create a sequence of TRUE or FALSE values, by asking whether each value in a sequence matches a particular condition. For example: 1:10 &gt; 5 [1] FALSE FALSE FALSE FALSE FALSE TRUE TRUE TRUE TRUE TRUE Re-using the heights vector from above, we can then use this to select values that are above the average: heights &gt; mean(heights) [1] TRUE FALSE FALSE FALSE FALSE FALSE TRUE FALSE TRUE TRUE FALSE [12] TRUE TRUE And we can use the vector of TRUE and FALSE values to select from the actual scores: heights[heights &gt; mean(heights)] [1] 203 172 172 187 182 175 It’s actually a matrix if has 2 dimensions, like a table, or an array if it has more than 2 dimensions.↩ i.e. edit the RMarkdown document↩ "],
["processing-vectors.html", "Processing vectors", " Processing vectors Many of R’s most useful functions process vectors of numbers in some way. For example (as we’ve already seen) if we want to calculate the average of our vector of heights we just type: mean(heights) [1] 167.6923 R contains lots of built in functions which we can use to summarise a vector of numbers. For example: median(heights) [1] 167 sd(heights) [1] 17.59443 min(heights) [1] 134 max(heights) [1] 203 range(heights) [1] 134 203 IQR(heights) [1] 17 length(heights) [1] 13 All of these functions accept a vector as input, do some proccesing, and then return a single number which gets displayed by RStudio. But not all functions return a single number in the way that mean did above. Some return a new vector, or some other type of object instead. For example, the quantile function returns the values at the 0, 25th, 50th, 75th and 100th percentiles (by default). height.quantiles &lt;- quantile(heights) height.quantiles 0% 25% 50% 75% 100% 134 158 167 175 203 If a function returns a vector, we can use it just like any other vector: height.quantiles &lt;- quantile(heights) # grab the third element, which is the median height.quantiles[3] 50% 167 # assign the first element to a variable min.height &lt;- height.quantiles[1] min.height 0% 134 But other functions process a vector without returning any numbers. For example, the hist function returns a histogram: hist(heights) We’ll cover lots more plotting and visualisation later on. Making new vectors So far we’ve seen R functions which process a vector of numbers and produce a single number, a new vector of a different length (like quantile or fivenum), or some other object (like hist which makes a plot). However many other functions accept a single input, do something to it, and return a single processed value. For example, the square root function, sqrt, accepts a single value and returns a single value: running sqrt(10) will return 3.1623. In R, if a function accepts a single value as input and returns a single value as output (like sqrt(10)), then you can usually give a vector as input too. Some people find this surprising3, but R assumes that if you’re processing a vector of numbers, you want the function applied to each of them in the same way. This turns out to be very useful. For example, let’s say we want the square root of each of the elements of our height data: # these are the raw values heights [1] 203 148 156 158 167 162 172 164 172 187 134 182 175 # takes the sqrt of each value and returns a vector of all the square roots sqrt(heights) [1] 14.24781 12.16553 12.49000 12.56981 12.92285 12.72792 13.11488 [8] 12.80625 13.11488 13.67479 11.57584 13.49074 13.22876 This also works with simple arithmetic So, if we wanted to convert all the heights from cm to meters we could just type: heights / 100 [1] 2.03 1.48 1.56 1.58 1.67 1.62 1.72 1.64 1.72 1.87 1.34 1.82 1.75 This trick also works with other functions like paste, which combines the inputs you send it to produce an alphanumeric string: paste(&quot;Once&quot;, &quot;upon&quot;, &quot;a&quot;, &quot;time&quot;) [1] &quot;Once upon a time&quot; If we send a vector to paste it assumes we want a vector of results, with each element in the vector pasted next to each other: bottles &lt;- c(100, 99, 98, &quot;...&quot;) paste(bottles, &quot;green bottles hanging on the wall&quot;) [1] &quot;100 green bottles hanging on the wall&quot; [2] &quot;99 green bottles hanging on the wall&quot; [3] &quot;98 green bottles hanging on the wall&quot; [4] &quot;... green bottles hanging on the wall&quot; In other programming languages we might have had to write a ‘loop’ to create each line of the song, but R lets us write short statements to summarise what needs to be done; we don’t need to worry worrying about how it gets done. The paste0 function does much the same, but leaves no spaces in the combined strings, which can be useful: paste0(&quot;N=&quot;, 1:10) [1] &quot;N=1&quot; &quot;N=2&quot; &quot;N=3&quot; &quot;N=4&quot; &quot;N=5&quot; &quot;N=6&quot; &quot;N=7&quot; &quot;N=8&quot; &quot;N=9&quot; &quot;N=10&quot; Making up data (new vectors) Sometimes you’ll need to create vectors containing regular sequences or randomly selected numbers. To create regular sequences a convenient shortcut is the ‘colon’ operator. For example, if we type 1:10 then we get a vector of numbers from 1 to 10: 1:10 [1] 1 2 3 4 5 6 7 8 9 10 The seq function allows you to create more specific sequences: # make a sequence, specifying the interval between them seq(from=0.1, to=2, by=.1) [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 1.1 1.2 1.3 1.4 1.5 1.6 1.7 [18] 1.8 1.9 2.0 We can also use random number-generating functions built into R to create vectors: # 10 uniformly distributed random numbers between 0 and 1 runif(10) [1] 0.6126703 0.4520277 0.3905088 0.9166254 0.3202581 0.5855937 0.9061971 [8] 0.9765845 0.5202774 0.5666197 # 1,000 uniformly distributed random numbers between 1 and 100 my.numbers &lt;- runif(1000, 1, 10) # 10 random-normal numbers with mean 10 and SD=1 rnorm(10, mean=10) [1] 9.704247 11.552676 12.274657 12.030825 11.160548 9.682790 9.826141 [8] 10.193990 9.147506 9.520177 # 10 random-normal numbers with mean 10 and SD=5 rnorm(10, 10, 5) [1] 14.567034 9.067716 9.278458 6.835906 8.390221 14.861313 9.136580 [8] 7.658026 14.550540 8.731716 We can then use these numbers in our code, for example plotting them: random.numbers &lt;- rnorm(10000) hist(random.numbers) Mostly people who already know other programming languages like C. It’s not that surprising if you read the R code as you would English.↩ "],
["functions-to-learn-now.html", "Functions to learn now", " Functions to learn now There are thousands of functions built into R. Below are just a few examples which are likely to be useful as you work with your data: Repetition # repeat something N times rep(&quot;Apple pie&quot;, 10) [1] &quot;Apple pie&quot; &quot;Apple pie&quot; &quot;Apple pie&quot; &quot;Apple pie&quot; &quot;Apple pie&quot; [6] &quot;Apple pie&quot; &quot;Apple pie&quot; &quot;Apple pie&quot; &quot;Apple pie&quot; &quot;Apple pie&quot; # repeat a short vector, combining into a single longer vector rep(c(&quot;Custard&quot;, &quot;Gravy&quot;), 5) [1] &quot;Custard&quot; &quot;Gravy&quot; &quot;Custard&quot; &quot;Gravy&quot; &quot;Custard&quot; &quot;Gravy&quot; &quot;Custard&quot; [8] &quot;Gravy&quot; &quot;Custard&quot; &quot;Gravy&quot; Sequences # make a sequence (countdown &lt;- 100:1) [1] 100 99 98 97 96 95 94 93 92 91 90 89 88 87 86 85 84 [18] 83 82 81 80 79 78 77 76 75 74 73 72 71 70 69 68 67 [35] 66 65 64 63 62 61 60 59 58 57 56 55 54 53 52 51 50 [52] 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 [69] 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 [86] 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 Make sequences with steps of a particular size: (tenths &lt;- seq(from=0, to=1, by=.1)) [1] 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 (twelfths &lt;- seq(from=0, to=10, length.out=12)) [1] 0.0000000 0.9090909 1.8181818 2.7272727 3.6363636 4.5454545 [7] 5.4545455 6.3636364 7.2727273 8.1818182 9.0909091 10.0000000 Ranking # generate some random data (here, ages in years) ages &lt;- round(rnorm(10, mean=40, sd=10)) # get the rank order of elements (i.e. what their positions would be if the vector was sorted) ages [1] 41 33 26 45 38 38 37 32 50 48 rank(ages, ties.method=&quot;first&quot;) [1] 7 3 1 8 5 6 4 2 10 9 Unique values # return the unique values in a vector unique(rep(1:10, 100)) [1] 1 2 3 4 5 6 7 8 9 10 Lengths # return the unique values in a vector length(seq(1,100, 2)) [1] 50 Try and experiment with each of these functions. Check the output against what you expected to happen, and make sure you understand what they do. "],
["lists.html", "Lists", " Lists Try running the code below: (confusing.vector &lt;- c(1, 2, 3, &quot;Wibble&quot;)) [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;Wibble&quot; (first.element &lt;- confusing.vector[1]) [1] &quot;1&quot; sqrt(first.element) Error in sqrt(first.element): non-numeric argument to mathematical function Take a minute to try and make a guess at what went wrong. Why does R complain that the 1 is non-numeric? When we built the vector we used c to combine the elements 1, 2, 3 and &quot;Wibble&quot;. Although our first three elements are numbers, &quot;Wibble&quot; is not - it’s made up of letters (this is called a character string). Vectors can only contain one type of thing so R automatically converts all the elements to the same type, if it can. Because R can’t reliably convert &quot;Wibble&quot; to a number, everything in the vector was converted to the character type instead. We get an error because R can’t mutiply words together. If you’re not sure what type of thing your vector contains, you can use the typeof function: typeof(1:10) [1] &quot;integer&quot; typeof(runif(10)) [1] &quot;double&quot; typeof(c(1, 2, &quot;Wibble&quot;)) [1] &quot;character&quot; Here the meaning of integer should be self explanatory. The vector runif(10) has type double, because it contains ‘double-precision’ floating point numbers. For our purposes you can just think of double as meaning any number with decimal places. The last vector has the type character because it includes the character string Wibble, and all the other numbers in it were coerced to become character strings too. If we want to (safely) mix up different types of object without them being converted we need a proper list, rather than a vector. In R we would write: my.list &lt;- list(2, 2, &quot;Wibble&quot;) We can still access elements from lists as we do for vectors, although now we need to use double square brackets, for example: my.list[[1]] [1] 2 But now our numbers haven’t been converted to character strings, and we can still multiply them. my.list[[1]] * my.list[[2]] [1] 4 Square brackets are ugly and can be confusing though, so we often give names to the elements of our list when we create it: my.party &lt;- list(number.guests=8, when=&quot;Friday&quot;, drinks = c(&quot;Juice&quot;, &quot;Beer&quot;, &quot;Whisky&quot;)) Which means we can then access the elements by name later on. To do this, you write the name of the vector, then a $ sign, and then the name of the element you want to access: my.party$when [1] &quot;Friday&quot; You might have spotted that we included a vector inside the party list. This is not a problem, and we can still access individual elements of this vector too: my.party$drinks[1] [1] &quot;Juice&quot; Create a vector containing 3 numbers then: Access just the last number Create a new vector containing just the first and last number Create a list containing your address and your age in years. Then: Multiply your age in years by your flat or house number (by accessing the relevant elements in the list) Run the following R code and explain what has happened: sqrt(1:10) * 10 [1] 10.00000 14.14214 17.32051 20.00000 22.36068 24.49490 26.45751 [8] 28.28427 30.00000 31.62278 Extended questions: What is the average of the 9 times table, up to and including 9 x 1000? Use the paste and c(...) functions to create a vector which contains the sequence “1 elephant”, “2 elephants”, …, “1000 elephants”. "]
]

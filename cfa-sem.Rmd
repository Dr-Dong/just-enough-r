---
title: 'Covariance modelling'
output:
  bookdown::tufte_html2
---


```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, collapse=TRUE, cache=TRUE, message=F)
library(tufte)
library(tidyverse)
library(pander)
```


# Covariance modelling

<!-- 
Differences CFA EFA
https://jonathantemplin.com/files/multivariate/mv11icpsr/mv11icpsr_lecture12.pdf 

Writing up CFA: http://www.understandingdata.net/2017/03/22/cfa-in-lavaan/#writeup


Nice reference guide: https://www.scribd.com/document/238478414/Beaujean-Latent-Variable-Modeling-Using-r

-->


This section covers path analysis (path models), confirmatory factor analysis (CFA) and structural equation modelling (SEM). You are encouraged to work through the path models and CFA sections, and especially the material on assessing model fit, before tacking SEM.


Before you start this either section make sure you have the `lavaan` package installed (see [installing packages](#packages)]).

```{r, eval=F}
install.packages(lavaan)
```

And we load the package to [make all the functions available with minimal typing](#package-namespacing):

```{r, message=F}
library(lavaan)
```


[The CFA examples were adapted from a guide originally produced by Jon May]{.explainer}






## Path models {- #path-models}


Path models are an extension of linear regression, but where 
multiple observed variables can be considered as 'outcomes'.

Because the terminology of outcomes v.s. predictors breaks down when variables can be both otucomes and predictors at the same time, it's normal to distinguish instead between:

- *Exogenous* variables (those which are not predicted by any other)

- *Endogenous* variables (variables which do have predictors, and may or may not predict other variales)




### Defining the model {-}


```{r, include=F, echo=F}
# setup some data for the example below
mm <- "
  y ~ 10*1 + .1*x + .3*m
  m ~ 5*1 + .5*x
"
mediation.df <- lavaan::simulateData(mm, sample.nobs=200,
                                     meanstructure=T,
                                     seed="1234")
```


To define a path model, `lavaan` requires that you specify the relationships between variables in a text format.  A full [guide to this lavaan model syntax](http://lavaan.ugent.be/tutorial/syntax1.html) is available on the project website. 

For path models the format is very simple, and resembles a series of linear models, written over several lines:

```{r}
# define the model over multiple lines for clarity
mediation.model <- "
  y ~ x + m
  m ~ x
"
```


In this case the `~` symbols just means 'regressed on' or 'is predicted by'. The model in the example above defines that our outcome `y` is predicted by both `x` and `m`, and that `x` also predicts `m`. You might recognise this as a [mediation model](#mediation).

To fit the model we pass the model specification and the data to the `sem()` function:

```{r}
mediation.fit <- sem(mediation.model, data=mediation.df)
```

As we did for [linear regression models](#linear-models-simple), we have saved the model fit object into a variable, here named `mediation.fit`. 

To display the model results we can use `summary()`. The key section of the output to check is the table listed 'Regressions', which lists the regression parameters for the predictors for each of the endogenous variables.

```{r}
summary(mediation.fit)
```



From this table we can see that both `x` and `m` are significant predictors of `y`, and that `x` also predicts `m`. This implie that mediation is taking place, but [see the mediation chapter](#mediation) for details of testing indirect effects in `lavaan`.



#### Where's the intercept? {-}

Path analysis is part of the set of techniques often termed 'covariance modelling', and as the name implies the primary focus here is the relationships between variables, and less so the mean-structure of the variables. In fact, by default the software first creates the covariance matrix of all the variables in the model, and the fit is based only on these values, plus the sample sizes (in early SEM software you typically had to provide the covariance matrix directly, rather than working with the raw data).

Nonetheless, because path analysis is an extension of regression techniques it is possible to request that intercepts are included in the model, and means estimates, by adding `meanstructure=TRUE` to the `sem()` function ([see the `lavaan` manual for details](http://lavaan.ugent.be/tutorial/means.html)). 

In the output below we now also see a table labelled 'Intercepts' which gives the mean values of each variable *when it's predictors are zero* (just like in linear regression):

```{r}
mediation.fit.means <- sem(mediation.model, 
                           meanstructure=T,
                           data=mediation.df)

summary(mediation.fit.means)
```



#### Tables of model coefficients {-}

If you want to present results from these models in table format, the `parameterEstimates()` function is useful to extract the relevant numbers as a dataframe. We can then manipulate and present this table as we would any other dataframe. 

In the example below we extract the parameter estimates, select only the regression parameters (`~`) and remove some of the columns to make the final output easier to read:

```{r}
parameterEstimates(mediation.fit.means) %>%
  filter(op == "~") %>% 
  mutate(term = paste(lhs, op, rhs)) %>%  
  select(term, everything(), -se, -lhs, -rhs, -op) %>% 
  pandoc.table(caption="Regression parameters from `mediation.fit`")

```



#### Diagrams {-}

Because describing path, CFA and SEM models in words can be tedious and difficult for readers to follow it is conventional to include a diagram of (at least) your final model, and perhaps also initial or alternative models.

The `semPlot::` package makes this relatively easy: passing a fitted `lavaan` model to the `semPaths()` function produces a line drawing, and gives the option to overlap raw or standardised coefficients over this drawing:

```{r}
# unfortunately semPaths plots very small by default, so we set
# some extra parameters to increase the size to make it readable
semPlot::semPaths(mediation.fit, "par",
             sizeMan = 15, sizeInt = 15, sizeLat = 15,
             edge.label.cex=1.5, 
             fade=FALSE)
```



## Confirmatory factor analysis (CFA) {- #cfa}


Open some data and check that all looks well:

```{r}
hz <- lavaan::HolzingerSwineford1939
hz %>% glimpse()
```


### Defining the model {-}

As noted above, to define models in `lavaan` you must specify the relationships between variables in a text format.  A full [guide to this lavaan model syntax](http://lavaan.ugent.be/tutorial/syntax1.html) is available on the project website.

For CFA models, like path models, the format is fairly simple, and resembles a series of linear models, written over several lines.

In the model below there are three latent variables, `visual`, `writing` and `maths`. The latent variable names are followed by =~ which means 'is manifested by', and then the observed variables, our measures for the latent variable, are listed, separated by the `+` symbol.


```{r}
hz.model <- '
visual =~ x1 + x2 + x3
writing =~ x4 + x5 + x6
maths =~ x7 + x8 + x9'
```

Note that we have saved our model specification/syntax in a variable named `hz.model`.


The other special symbols in the `lavaan` syntax which can be used for CFA models are:

- `a ~~ b`, which represents a *covariance*.

- `a ~~ a`, which is a *variance* (you can think of this as the covariance of a variable with itself)


To run the analysis we again pass the model specification and the data to the `cfa()` function:

```{r}
hz.fit <- cfa(hz.model, data=hz)
summary(hz.fit, standardized=TRUE)
```


#### Model output {-}
The output has three parts:

1. Parameter estimates. The values in the first column are the standardised weights from the observed variables to the latent factors.

2. Factor covariances. The values in the first column are the covariances between the latent factors.

3. Error variances. The values in the first column are the estimates of each observed variableâ€™s error variance.



#### Plotting models {-}

As before, we can use the `semPaths()` function to visualise the model. This is an important step because it helps explain the model to others, and also gives you an opportunity to check you have specified your model correctly.

```{r}
semPlot::semPaths(hz.fit)
```

And for 'final' models we might want to overplot model parameter estimates (in this case, standardised):

```{r}
# std refers to standardised estimates. "par" would plot
# the unstandardised estimates
semPlot::semPaths(hz.fit, "std")
```




## Model fit {-}

To examine the model fit we use `fitmeasures()` and pass a list of the names of the fit indices we would like calculated:

```{r}
fitmeasures(hz.fit, c('cfi', 'rmsea', 'rmsea.ci.upper', 'bic')) 
```

This looks OK, but the fit indices indicate the model could be improved. In particular the RMSEA figure is above 0.05. See the [notes on goodness of fit statistics](#gof) for more detail.




## Modification indices {-}

To examine the modification indices we type:

```{r, echo=T, eval=F}
modificationindices(hz.fit)
```


But because this function produces a very long table of output, it can be helpful to sort and filter the rows to show only those model modifications which might be of interes to us. 

The command below converts the output of `modificationindices()` to a dataframe. It then:

- Sorts the rows by the `mi` column, which represents the change in model \chi^2^ we see if the path was included (see [sorting](#sorting))
- Filters the results to show only those with \chi^2^ change > 5
- Selects only the `lhs`, `op`, `rhs`, `mi`, and `epc` columns.

```{r}
modificationindices(hz.fit) %>% 
  as.data.frame() %>% 
  arrange(-mi) %>% 
  filter(mi > 5) %>% 
  select(lhs, op, rhs, mi, epc) %>% 
  pandoc.table(caption="Largest MI values for hz.fit")
```


The `lhs` (left hand side), `rhs` (right hans side) and `op` (operation) columns specify what modification should be made. 

Latent factor to variable links have `=~` in the 'op' column. Error covariances for observed variables have `~~` as the op. These symbols match the symbols used to describe a path in the lavaan model syntax.

If we add the largest MI path to our model it will look like this:

```{r}
# same model, but with x9 now loading on visual
hz.model.2 <- "
visual =~ x1 + x2 + x3 + x9
writing =~ x4 + x5 + x6
maths =~ x7 + x8 + x9"

hz.fit.2 <- cfa(hz.model.2, data=hz)
fitmeasures(hz.fit.2, c('cfi', 'rmsea', 'rmsea.ci.upper', 'bic'))
```

RMSEA has improved somewhat, but we'd probably want to investigate this model further, and make additional improvements to it (although see the notes on [model improvements](#model-improvement))


## Missing data {-}

If you have missing data, add the argument `estimator='MLM'` to the `cfa()` function to use a [robust method](https://en.wikipedia.org/wiki/Robust_statistics). There are no missing data in this dataset, but it would look like this:

```{r}
hz.fit.2.mlm <- cfa(hz.model.2, data=hz, estimator="MLM")
hz.fit.2.mlm
```




## Structural eqution modelling {- #sem}




- do CFA first
- lavaan for structural models




